// This file was automatically generated by Java-GI. Do not edit this file
// directly! Visit <https://java-gi.org> for more information.
//
// The API documentation in this file was derived from GObject-Introspection
// metadata and may include text or comments from the original C sources.
//
// Copyright (c), upstream authors of the GObject-Introspection data.
//
// This generated file is distributed under the same license as the original
// GObject-Introspection data, unless otherwise specified. Users of this file
// are responsible for complying with any licenses or terms required by the
// original authors.
//
// THIS FILE IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, AND NONINFRINGEMENT.
//
package goa;

import java.lang.String;
import java.lang.foreign.FunctionDescriptor;
import java.lang.foreign.MemorySegment;
import java.lang.foreign.ValueLayout;
import java.lang.invoke.MethodHandle;
import javax.annotation.processing.Generated;
import org.javagi.base.TransferOwnership;
import org.javagi.gobject.types.TypeCache;
import org.javagi.interop.Interop;
import org.javagi.interop.Platform;

/**
 * Constants and functions that are declared in the global Goa namespace.
 */
@Generated("io.github.jwharm.JavaGI")
public final class Goa {
    public static final int ERROR_NUM_ENTRIES = 6;

    /**
     * The major version number of the GOA daemon and library.
     * <p>
     * Like {@code goa_major_version}, but from the headers used at
     * application compile time, rather than from the library
     * linked against at application run time.
     *
     * @since 3.8
     */
    public static final int MAJOR_VERSION = 3;

    /**
     * The micro version number of the GOA daemon and library.
     * <p>
     * Like {@code goa_micro_version}, but from the headers used at
     * application compile time, rather than from the library
     * linked against at application run time.
     *
     * @since 3.8
     */
    public static final int MICRO_VERSION = 2;

    /**
     * The minor version number of the GOA daemon and library.
     * <p>
     * Like {@code goa_minor_version}, but from the headers used at
     * application compile time, rather than from the library
     * linked against at application run time.
     *
     * @since 3.8
     */
    public static final int MINOR_VERSION = 56;

    static {
        switch (Platform.getRuntimePlatform()) {
            case LINUX -> Interop.loadLibrary("libgoa-1.0.so.0");
            // add windows library here
            // add macos library here
        }
        registerTypes();
    }

    public static void javagi$ensureInitialized() {
    }

    private static void registerTypes() {
        TypeCache.register(AccountProxy.class, AccountProxy.getType(), AccountProxy::new, AccountProxy.AccountProxyClass::new);
        TypeCache.register(AccountSkeleton.class, AccountSkeleton.getType(), AccountSkeleton::new, AccountSkeleton.AccountSkeletonClass::new);
        TypeCache.register(CalendarProxy.class, CalendarProxy.getType(), CalendarProxy::new, CalendarProxy.CalendarProxyClass::new);
        TypeCache.register(CalendarSkeleton.class, CalendarSkeleton.getType(), CalendarSkeleton::new, CalendarSkeleton.CalendarSkeletonClass::new);
        TypeCache.register(ChatProxy.class, ChatProxy.getType(), ChatProxy::new, ChatProxy.ChatProxyClass::new);
        TypeCache.register(ChatSkeleton.class, ChatSkeleton.getType(), ChatSkeleton::new, ChatSkeleton.ChatSkeletonClass::new);
        TypeCache.register(Client.class, Client.getType(), Client::new, Client.ClientClass::new);
        TypeCache.register(ContactsProxy.class, ContactsProxy.getType(), ContactsProxy::new, ContactsProxy.ContactsProxyClass::new);
        TypeCache.register(ContactsSkeleton.class, ContactsSkeleton.getType(), ContactsSkeleton::new, ContactsSkeleton.ContactsSkeletonClass::new);
        TypeCache.register(DocumentsProxy.class, DocumentsProxy.getType(), DocumentsProxy::new, DocumentsProxy.DocumentsProxyClass::new);
        TypeCache.register(DocumentsSkeleton.class, DocumentsSkeleton.getType(), DocumentsSkeleton::new, DocumentsSkeleton.DocumentsSkeletonClass::new);
        TypeCache.register(ExchangeProxy.class, ExchangeProxy.getType(), ExchangeProxy::new, ExchangeProxy.ExchangeProxyClass::new);
        TypeCache.register(ExchangeSkeleton.class, ExchangeSkeleton.getType(), ExchangeSkeleton::new, ExchangeSkeleton.ExchangeSkeletonClass::new);
        TypeCache.register(FilesProxy.class, FilesProxy.getType(), FilesProxy::new, FilesProxy.FilesProxyClass::new);
        TypeCache.register(FilesSkeleton.class, FilesSkeleton.getType(), FilesSkeleton::new, FilesSkeleton.FilesSkeletonClass::new);
        TypeCache.register(MailProxy.class, MailProxy.getType(), MailProxy::new, MailProxy.MailProxyClass::new);
        TypeCache.register(MailSkeleton.class, MailSkeleton.getType(), MailSkeleton::new, MailSkeleton.MailSkeletonClass::new);
        TypeCache.register(ManagerProxy.class, ManagerProxy.getType(), ManagerProxy::new, ManagerProxy.ManagerProxyClass::new);
        TypeCache.register(ManagerSkeleton.class, ManagerSkeleton.getType(), ManagerSkeleton::new, ManagerSkeleton.ManagerSkeletonClass::new);
        TypeCache.register(MapsProxy.class, MapsProxy.getType(), MapsProxy::new, MapsProxy.MapsProxyClass::new);
        TypeCache.register(MapsSkeleton.class, MapsSkeleton.getType(), MapsSkeleton::new, MapsSkeleton.MapsSkeletonClass::new);
        TypeCache.register(MediaServerProxy.class, MediaServerProxy.getType(), MediaServerProxy::new, MediaServerProxy.MediaServerProxyClass::new);
        TypeCache.register(MediaServerSkeleton.class, MediaServerSkeleton.getType(), MediaServerSkeleton::new, MediaServerSkeleton.MediaServerSkeletonClass::new);
        TypeCache.register(MusicProxy.class, MusicProxy.getType(), MusicProxy::new, MusicProxy.MusicProxyClass::new);
        TypeCache.register(MusicSkeleton.class, MusicSkeleton.getType(), MusicSkeleton::new, MusicSkeleton.MusicSkeletonClass::new);
        TypeCache.register(OAuth2BasedProxy.class, OAuth2BasedProxy.getType(), OAuth2BasedProxy::new, OAuth2BasedProxy.OAuth2BasedProxyClass::new);
        TypeCache.register(OAuth2BasedSkeleton.class, OAuth2BasedSkeleton.getType(), OAuth2BasedSkeleton::new, OAuth2BasedSkeleton.OAuth2BasedSkeletonClass::new);
        TypeCache.register(OAuthBasedProxy.class, OAuthBasedProxy.getType(), OAuthBasedProxy::new, OAuthBasedProxy.OAuthBasedProxyClass::new);
        TypeCache.register(OAuthBasedSkeleton.class, OAuthBasedSkeleton.getType(), OAuthBasedSkeleton::new, OAuthBasedSkeleton.OAuthBasedSkeletonClass::new);
        TypeCache.register(ObjectManagerClient.class, ObjectManagerClient.getType(), ObjectManagerClient::new, ObjectManagerClient.ObjectManagerClientClass::new);
        TypeCache.register(ObjectProxy.class, ObjectProxy.getType(), ObjectProxy::new, ObjectProxy.ObjectProxyClass::new);
        TypeCache.register(ObjectSkeleton.class, ObjectSkeleton.getType(), ObjectSkeleton::new, ObjectSkeleton.ObjectSkeletonClass::new);
        TypeCache.register(PasswordBasedProxy.class, PasswordBasedProxy.getType(), PasswordBasedProxy::new, PasswordBasedProxy.PasswordBasedProxyClass::new);
        TypeCache.register(PasswordBasedSkeleton.class, PasswordBasedSkeleton.getType(), PasswordBasedSkeleton::new, PasswordBasedSkeleton.PasswordBasedSkeletonClass::new);
        TypeCache.register(PhotosProxy.class, PhotosProxy.getType(), PhotosProxy::new, PhotosProxy.PhotosProxyClass::new);
        TypeCache.register(PhotosSkeleton.class, PhotosSkeleton.getType(), PhotosSkeleton::new, PhotosSkeleton.PhotosSkeletonClass::new);
        TypeCache.register(PrintersProxy.class, PrintersProxy.getType(), PrintersProxy::new, PrintersProxy.PrintersProxyClass::new);
        TypeCache.register(PrintersSkeleton.class, PrintersSkeleton.getType(), PrintersSkeleton::new, PrintersSkeleton.PrintersSkeletonClass::new);
        TypeCache.register(ReadLaterProxy.class, ReadLaterProxy.getType(), ReadLaterProxy::new, ReadLaterProxy.ReadLaterProxyClass::new);
        TypeCache.register(ReadLaterSkeleton.class, ReadLaterSkeleton.getType(), ReadLaterSkeleton::new, ReadLaterSkeleton.ReadLaterSkeletonClass::new);
        TypeCache.register(TicketingProxy.class, TicketingProxy.getType(), TicketingProxy::new, TicketingProxy.TicketingProxyClass::new);
        TypeCache.register(TicketingSkeleton.class, TicketingSkeleton.getType(), TicketingSkeleton::new, TicketingSkeleton.TicketingSkeletonClass::new);
        TypeCache.register(TodoProxy.class, TodoProxy.getType(), TodoProxy::new, TodoProxy.TodoProxyClass::new);
        TypeCache.register(TodoSkeleton.class, TodoSkeleton.getType(), TodoSkeleton::new, TodoSkeleton.TodoSkeletonClass::new);
        TypeCache.register(Account.class, Account.getType(), Account.Account$Impl::new, Account.AccountIface::new);
        TypeCache.register(Calendar.class, Calendar.getType(), Calendar.Calendar$Impl::new, Calendar.CalendarIface::new);
        TypeCache.register(Chat.class, Chat.getType(), Chat.Chat$Impl::new, Chat.ChatIface::new);
        TypeCache.register(Contacts.class, Contacts.getType(), Contacts.Contacts$Impl::new, Contacts.ContactsIface::new);
        TypeCache.register(Documents.class, Documents.getType(), Documents.Documents$Impl::new, Documents.DocumentsIface::new);
        TypeCache.register(Exchange.class, Exchange.getType(), Exchange.Exchange$Impl::new, Exchange.ExchangeIface::new);
        TypeCache.register(Files.class, Files.getType(), Files.Files$Impl::new, Files.FilesIface::new);
        TypeCache.register(Mail.class, Mail.getType(), Mail.Mail$Impl::new, Mail.MailIface::new);
        TypeCache.register(Manager.class, Manager.getType(), Manager.Manager$Impl::new, Manager.ManagerIface::new);
        TypeCache.register(Maps.class, Maps.getType(), Maps.Maps$Impl::new, Maps.MapsIface::new);
        TypeCache.register(MediaServer.class, MediaServer.getType(), MediaServer.MediaServer$Impl::new, MediaServer.MediaServerIface::new);
        TypeCache.register(Music.class, Music.getType(), Music.Music$Impl::new, Music.MusicIface::new);
        TypeCache.register(OAuth2Based.class, OAuth2Based.getType(), OAuth2Based.OAuth2Based$Impl::new, OAuth2Based.OAuth2BasedIface::new);
        TypeCache.register(OAuthBased.class, OAuthBased.getType(), OAuthBased.OAuthBased$Impl::new, OAuthBased.OAuthBasedIface::new);
        TypeCache.register(GoaObject.class, GoaObject.getType(), GoaObject.Object$Impl::new, GoaObject.ObjectIface::new);
        TypeCache.register(PasswordBased.class, PasswordBased.getType(), PasswordBased.PasswordBased$Impl::new, PasswordBased.PasswordBasedIface::new);
        TypeCache.register(Photos.class, Photos.getType(), Photos.Photos$Impl::new, Photos.PhotosIface::new);
        TypeCache.register(Printers.class, Printers.getType(), Printers.Printers$Impl::new, Printers.PrintersIface::new);
        TypeCache.register(ReadLater.class, ReadLater.getType(), ReadLater.ReadLater$Impl::new, ReadLater.ReadLaterIface::new);
        TypeCache.register(Ticketing.class, Ticketing.getType(), Ticketing.Ticketing$Impl::new, Ticketing.TicketingIface::new);
        TypeCache.register(Todo.class, Todo.getType(), Todo.Todo$Impl::new, Todo.TodoIface::new);
        TypeCache.registerEnum(GoaError.class, GoaError.getType(), GoaError::of);
    }

    /**
     * Checks that the GOA library in use is compatible with the given version.
     * <p>
     * Generally you would pass in the constants {@code Goa.MAJOR_VERSION},
     * {@code Goa.MINOR_VERSION}, {@code Goa.MICRO_VERSION} as three arguments to
     * this function; that produces a check that the library in use is compatible
     * with the version of GOA the application or module was compiled against.
     * <p>
     * Compatibility is defined by two things: first the version of the running
     * library is newer than the version
     * {@code requiredMicro.} Second the running library
     * must be binary compatible with the version
     * {@code requiredMicro} (same major and minor
     * version).
     *
     * @param requiredMajor the required major version.
     * @param requiredMinor the required minor version.
     * @param requiredMicro the required micro version.
     * @return {@code null} if the GOA library is compatible with the
     *   given version, or a string describing the version mismatch.
     * @since 3.8
     */
    public static String checkVersion(int requiredMajor, int requiredMinor, int requiredMicro) {
        MemorySegment _result;
        try {
            _result = (MemorySegment) MethodHandles.goa_check_version.invokeExact(requiredMajor, 
                    requiredMinor, requiredMicro);
        } catch (Throwable _err) {
            throw new AssertionError(_err);
        }
        if (_result == null || _result.equals(MemorySegment.NULL)) {
            return null;
        }
        String _returnValue = Interop.getStringFrom(_result, TransferOwnership.NONE);
        return _returnValue;
    }

    private static final class MethodHandles {
        static final MethodHandle goa_check_version = Interop.downcallHandle("goa_check_version",
                FunctionDescriptor.of(ValueLayout.ADDRESS, ValueLayout.JAVA_INT,
                ValueLayout.JAVA_INT, ValueLayout.JAVA_INT), false);
    }
}
