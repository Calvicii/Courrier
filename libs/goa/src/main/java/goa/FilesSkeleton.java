// This file was automatically generated by Java-GI. Do not edit this file
// directly! Visit <https://github.com/jwharm/java-gi/> for more information.
//
// The API documentation in this file was derived from GObject-Introspection
// metadata and may include text or comments from the original C sources.
//
// Copyright (c), upstream authors as identified in the GObject-Introspection
// metadata.
//
// This generated file is distributed under the same license as the original
// GObject-Introspection data, unless otherwise specified. Users of this file
// are responsible for complying with any licenses or terms required by the
// original authors.
//
// THIS FILE IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, AND NONINFRINGEMENT.
//
package goa;

import io.github.jwharm.javagi.gobject.InstanceCache;
import io.github.jwharm.javagi.gobject.types.TypeCache;
import io.github.jwharm.javagi.interop.Interop;
import java.lang.foreign.Arena;
import java.lang.foreign.MemoryLayout;
import java.lang.foreign.MemorySegment;
import java.lang.foreign.ValueLayout;
import javax.annotation.processing.Generated;
import org.gnome.gio.DBusInterface;
import org.gnome.gio.DBusInterfaceSkeleton;
import org.gnome.glib.Type;
import org.gnome.gobject.GObject;
import org.gnome.gobject.Value;

/**
 * The {@code GoaFilesSkeleton} structure contains only private data and should only be accessed using the provided API.
 *
 * @since 3.8.0
 */
@Generated("io.github.jwharm.JavaGI")
public class FilesSkeleton extends DBusInterfaceSkeleton implements DBusInterface, Files {
    static {
        Goa.javagi$ensureInitialized();
    }

    /**
     * Create a FilesSkeleton proxy instance for the provided memory address.
     *
     * @param address the memory address of the native object
     */
    public FilesSkeleton(MemorySegment address) {
        super(Interop.reinterpret(address, getMemoryLayout().byteSize()));
    }

    /**
     * Creates a new FilesSkeleton.
     */
    public FilesSkeleton() {
        super((MemorySegment) null);
        InstanceCache.newGObject(this, TypeCache.getType(this.getClass()), getMemoryLayout().byteSize(), (Object[]) null);
    }

    /**
     * Get the GType of the FilesSkeleton class
     *
     * @return the GType
     */
    public static Type getType() {
        return Interop.getType("goa_files_skeleton_get_type");
    }

    /**
     * The memory layout of the native struct.
     * @return the memory layout
     */
    public static MemoryLayout getMemoryLayout() {
        return MemoryLayout.structLayout(
            DBusInterfaceSkeleton.getMemoryLayout().withName("parent_instance"),
            ValueLayout.ADDRESS.withName("priv")
        ).withName("GoaFilesSkeleton");
    }

    /**
     * Returns this instance as if it were its parent type. This is mostly
     * synonymous to the Java {@code super} keyword, but will set the native
     * typeclass function pointers to the parent type. When overriding a native
     * virtual method in Java, "chaining up" with {@code super.methodName()}
     * doesn't work, because it invokes the overridden function pointer again.
     * To chain up, call {@code asParent().methodName()}. This will call the
     * native function pointer of this virtual method in the typeclass of the
     * parent type.
     */
    protected FilesSkeleton asParent() {
        FilesSkeleton _parent = new FilesSkeleton(handle());
        _parent.callParent(true);
        return _parent;
    }

    /**
     * A {@link Builder} object constructs a {@code FilesSkeleton}
     * with the specified properties.
     * Use the various {@code set...()} methods to set properties,
     * and finish construction with {@link Builder#build()}.
     */
    public static Builder<? extends Builder> builder() {
        return new Builder<>();
    }

    /**
     * Class structure for {@code GoaFilesSkeleton}.
     *
     * @since 3.8.0
     */
    public static class FilesSkeletonClass extends DBusInterfaceSkeleton.DBusInterfaceSkeletonClass {
        /**
         * Create a FilesSkeletonClass proxy instance for the provided memory address.
         *
         * @param address the memory address of the native object
         */
        public FilesSkeletonClass(MemorySegment address) {
            super(Interop.reinterpret(address, getMemoryLayout().byteSize()));
        }

        /**
         * Allocate a new FilesSkeletonClass.
         *
         * @param arena to control the memory allocation scope
         */
        public FilesSkeletonClass(Arena arena) {
            super(arena.allocate(getMemoryLayout()));
        }

        /**
         * Allocate a new FilesSkeletonClass.
         * The memory is allocated with {@link Arena#ofAuto}.
         */
        public FilesSkeletonClass() {
            super(Arena.ofAuto().allocate(getMemoryLayout()));
        }

        /**
         * The memory layout of the native struct.
         * @return the memory layout
         */
        public static MemoryLayout getMemoryLayout() {
            return MemoryLayout.structLayout(
                DBusInterfaceSkeleton.DBusInterfaceSkeletonClass.getMemoryLayout().withName("parent_class")
            ).withName("GoaFilesSkeletonClass");
        }
    }

    /**
     * Inner class implementing a builder pattern to construct a GObject with
     * properties.
     *
     * @param <B> the type of the Builder that is returned
     */
    public static class Builder<B extends Builder<B>> extends DBusInterfaceSkeleton.Builder<B> implements Files.Builder<B> {
        /**
         * Default constructor for a {@code Builder} object.
         */
        protected Builder() {
        }

        /**
         * Finish building the {@code FilesSkeleton} object. This will call
         * {@link GObject#withProperties} to create a new GObject instance,
         * which is then cast to {@code FilesSkeleton}.
         *
         * @return a new instance of {@code FilesSkeleton} with the properties
         *         that were set in the Builder object.
         */
        public FilesSkeleton build() {
            try {
                var _instance = (FilesSkeleton) GObject.withProperties(FilesSkeleton.getType(), getNames(), getValues());
                connectSignals(_instance.handle());
                return _instance;
            } finally {
                for (Value _value : getValues()) _value.unset();
                getArena().close();
            }
        }
    }
}
