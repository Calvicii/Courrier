// This file was automatically generated by Java-GI. Do not edit this file
// directly! Visit <https://github.com/jwharm/java-gi/> for more information.
//
// The API documentation in this file was derived from GObject-Introspection
// metadata and may include text or comments from the original C sources.
//
// Copyright (c), upstream authors as identified in the GObject-Introspection
// metadata.
//
// This generated file is distributed under the same license as the original
// GObject-Introspection data, unless otherwise specified. Users of this file
// are responsible for complying with any licenses or terms required by the
// original authors.
//
// THIS FILE IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, AND NONINFRINGEMENT.
//
package goa;

import io.github.jwharm.javagi.gobject.InstanceCache;
import io.github.jwharm.javagi.gobject.types.TypeCache;
import io.github.jwharm.javagi.interop.Interop;
import java.lang.String;
import java.lang.foreign.Arena;
import java.lang.foreign.FunctionDescriptor;
import java.lang.foreign.MemoryLayout;
import java.lang.foreign.MemorySegment;
import java.lang.foreign.ValueLayout;
import java.lang.invoke.MethodHandle;
import javax.annotation.processing.Generated;
import org.gnome.gio.DBusConnection;
import org.gnome.gio.DBusObject;
import org.gnome.gio.DBusObjectProxy;
import org.gnome.glib.Type;
import org.gnome.gobject.GObject;
import org.gnome.gobject.Value;

/**
 * The {@code GoaObjectProxy} structure contains only private data and should only be accessed using the provided API.
 */
@Generated("io.github.jwharm.JavaGI")
public class ObjectProxy extends DBusObjectProxy implements DBusObject, GoaObject {
    static {
        Goa.javagi$ensureInitialized();
    }

    /**
     * Create a ObjectProxy proxy instance for the provided memory address.
     *
     * @param address the memory address of the native object
     */
    public ObjectProxy(MemorySegment address) {
        super(Interop.reinterpret(address, getMemoryLayout().byteSize()));
    }

    /**
     * Creates a new proxy object.
     *
     * @param connection A {@code GDBusConnection}.
     * @param objectPath An object path.
     */
    public ObjectProxy(DBusConnection connection, String objectPath) {
        this(constructNew(connection, objectPath));
        InstanceCache.put(handle(), this);
    }

    /**
     * Creates a new ObjectProxy.
     */
    public ObjectProxy() {
        super((MemorySegment) null);
        InstanceCache.newGObject(this, TypeCache.getType(this.getClass()), getMemoryLayout().byteSize(), (Object[]) null);
    }

    /**
     * Get the GType of the ObjectProxy class
     *
     * @return the GType
     */
    public static Type getType() {
        return Interop.getType("goa_object_proxy_get_type");
    }

    /**
     * The memory layout of the native struct.
     * @return the memory layout
     */
    public static MemoryLayout getMemoryLayout() {
        return MemoryLayout.structLayout(
            DBusObjectProxy.getMemoryLayout().withName("parent_instance"),
            ValueLayout.ADDRESS.withName("priv")
        ).withName("GoaObjectProxy");
    }

    /**
     * Returns this instance as if it were its parent type. This is mostly
     * synonymous to the Java {@code super} keyword, but will set the native
     * typeclass function pointers to the parent type. When overriding a native
     * virtual method in Java, "chaining up" with {@code super.methodName()}
     * doesn't work, because it invokes the overridden function pointer again.
     * To chain up, call {@code asParent().methodName()}. This will call the
     * native function pointer of this virtual method in the typeclass of the
     * parent type.
     */
    protected ObjectProxy asParent() {
        ObjectProxy _parent = new ObjectProxy(handle());
        _parent.callParent(true);
        return _parent;
    }

    private static MemorySegment constructNew(DBusConnection connection, String objectPath) {
        try (var _arena = Arena.ofConfined()) {
            MemorySegment _result;
            try {
                _result = (MemorySegment) MethodHandles.goa_object_proxy_new.invokeExact(
                        (MemorySegment) (connection == null ? MemorySegment.NULL : connection.handle()), 
                        (MemorySegment) (objectPath == null ? MemorySegment.NULL : Interop.allocateNativeString(objectPath, _arena)));
            } catch (Throwable _err) {
                throw new AssertionError(_err);
            }
            return _result;
        }
    }

    /**
     * A {@link Builder} object constructs a {@code ObjectProxy}
     * with the specified properties.
     * Use the various {@code set...()} methods to set properties,
     * and finish construction with {@link Builder#build()}.
     */
    public static Builder<? extends Builder> builder() {
        return new Builder<>();
    }

    /**
     * Class structure for {@code GoaObjectProxy}.
     */
    public static class ObjectProxyClass extends DBusObjectProxy.DBusObjectProxyClass {
        /**
         * Create a ObjectProxyClass proxy instance for the provided memory address.
         *
         * @param address the memory address of the native object
         */
        public ObjectProxyClass(MemorySegment address) {
            super(Interop.reinterpret(address, getMemoryLayout().byteSize()));
        }

        /**
         * Allocate a new ObjectProxyClass.
         *
         * @param arena to control the memory allocation scope
         */
        public ObjectProxyClass(Arena arena) {
            super(arena.allocate(getMemoryLayout()));
        }

        /**
         * Allocate a new ObjectProxyClass.
         * The memory is allocated with {@link Arena#ofAuto}.
         */
        public ObjectProxyClass() {
            super(Arena.ofAuto().allocate(getMemoryLayout()));
        }

        /**
         * The memory layout of the native struct.
         * @return the memory layout
         */
        public static MemoryLayout getMemoryLayout() {
            return MemoryLayout.structLayout(
                DBusObjectProxy.DBusObjectProxyClass.getMemoryLayout().withName("parent_class")
            ).withName("GoaObjectProxyClass");
        }
    }

    /**
     * Inner class implementing a builder pattern to construct a GObject with
     * properties.
     *
     * @param <B> the type of the Builder that is returned
     */
    public static class Builder<B extends Builder<B>> extends DBusObjectProxy.Builder<B> implements GoaObject.Builder<B> {
        /**
         * Default constructor for a {@code Builder} object.
         */
        protected Builder() {
        }

        /**
         * Finish building the {@code ObjectProxy} object. This will call
         * {@link GObject#withProperties} to create a new GObject instance,
         * which is then cast to {@code ObjectProxy}.
         *
         * @return a new instance of {@code ObjectProxy} with the properties
         *         that were set in the Builder object.
         */
        public ObjectProxy build() {
            try {
                var _instance = (ObjectProxy) GObject.withProperties(ObjectProxy.getType(), getNames(), getValues());
                connectSignals(_instance.handle());
                return _instance;
            } finally {
                for (Value _value : getValues()) _value.unset();
                getArena().close();
            }
        }
    }

    private static final class MethodHandles {
        static final MethodHandle goa_object_proxy_new = Interop.downcallHandle(
                "goa_object_proxy_new", FunctionDescriptor.of(ValueLayout.ADDRESS,
                ValueLayout.ADDRESS, ValueLayout.ADDRESS), false);
    }
}
